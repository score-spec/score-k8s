# This example provisioner is a fake resource type used to demonstrate the template provisioner mechanism.
- uri: template://example-provisioners/example-provisioner
  # (Required) Which resource type to match
  type: example-provisioner-resource
  # (Optional) Which 'class' of the resource. Blank will match any class, a non-empty value like 'default' will match
  # only resources of that class.
  class: ""
  # (Optional) The exact resource id to match. Blank will match any resource, a non-empty value will only match
  # the resource with exact same id.
  id: ""
  # (Optional) The init template sets the initial context values on each provision request. This is a text template
  # that must evaluate to a YAML/JSON key-value map.
  init: |
    key: value
    # sprig functions are also supported
    key2: {{ print "value" | upper }}
  # (Optional) The state template gets evaluated next and sets the internal state of this resource based on the previous
  # state and the init context. Like init, this evaluates to a YAML/JSON object. This is the template that allows
  # state to be stored between each generate call.
  state: |
    state-key: {{ .Init.key }} # will copy the value from init
    state-key2: {{ default 0 .State.state-key2 | add 1 }} # will increment on each provision attempt
  # (Optional) The shared state template is like state, but is a key-value structure shared between all resources.
  # This can be used to coordinate shared resources and state between resources of the same or related types.
  shared: |
    section:
      key: {{ .Shared.foo }}
  # (Optional) The outputs template gets evaluated last and translates into the outputs available as placeholder
  # references like ${resources.my-resource.key}.
  outputs: |
    plaintext: my-value
    nested:
      example: thing
    # Instead of returning secret outputs as plaintext. They can be embedded as reference to Kubernetes Secrets. When
    # these are detected, they can be used in environment variables or file contents securely.
    secret-reference: {{ encodeSecretRef "my-secret" "my-key" }}

# As an example we have a 'volume' type which returns an emptyDir volume.
# In production or for real applications you may want to replace this with a provisioner for a tmpfs, host path, or
# persistent volume and claims.
- uri: template://default-provisioners/volume
  type: volume
  outputs: |
    source: 
      emptyDir: {}

# The default dns provisioner just outputs a random localhost domain because we don't know whether external-dns is
# available. You should replace this with your own dns name generation that matches your external-dns controller.
- uri: template://default-provisioners/dns
  type: dns
  init: |
    randomHostname: dns{{ randAlphaNum 6 | lower }}.localhost
  state: |
    instanceHostname: {{ dig "instanceHostname" .Init.randomHostname .State | quote }}
  outputs: |
    host: {{ .State.instanceHostname }}

# Routes could be implemented as either traditional ingress resources or using the newer gateway API.
# In this default provisioner we use the gateway API with some sensible defaults. But you may wish to replace this.
- uri: template://default-provisioners/route
  type: route
  init: |
    randomRouteName: routing-{{ .SourceWorkload }}-{{ randAlphaNum 6 | lower }}
    {{ if not (regexMatch "^/|(/([^/]+))+$" .Params.path) }}{{ fail "params.path start with a / but cannot end with /" }}{{ end }}
    {{ if not (regexMatch "^[a-z0-9_.-]{1,253}$" .Params.host) }}{{ fail (cat "params.host must be a valid hostname but was" .Params.host) }}{{ end }}
    {{ $ports := (index .WorkloadServices .SourceWorkload).Ports }}
    {{ if not $ports }}{{ fail "no service ports exist" }}{{ end }}
    {{ $port := index $ports (print .Params.port) }}
    {{ if not $port.TargetPort }}{{ fail "params.port is not a named service port" }}{{ end }}
  state: |
    routeName: {{ dig "routeName" .Init.randomRouteName .State | quote }}
  manifests: |
    - apiVersion: gateway.networking.k8s.io/v1
      kind: HTTPRoute
      metadata:
        name: {{ .State.routeName }}
        annotations:
          k8s.score.dev/source-workload: {{ .SourceWorkload }}
          k8s.score.dev/resource-uid: {{ .Uid }}
          k8s.score.dev/resource-guid: {{ .Guid }}
      spec:
        parentRefs:
        - name: default
        hostnames:
        - {{ .Params.host | quote }}
        rules:
        - matches:
          - path: 
              type: PathPrefix
              value: {{ .Params.path | quote }}
          backendRefs:
          - name: {{ (index .WorkloadServices .SourceWorkload).ServiceName }}
            port: {{ .Params.port }}

- uri: template://default-provisioners/postgres
  type: postgres
  init: |
    randomServiceName: pg-{{ randAlphaNum 6 | lower }}
    randomDatabase: db-{{ randAlpha 8 }}
    randomUsername: user-{{ randAlpha 8 }}
    randomPassword: {{ randAlphaNum 16 | quote }}
  state: |
    service: {{ dig "service" .Init.randomServiceName .State | quote }}
    database: {{ dig "database" .Init.randomDatabase .State | quote }}
    username: {{ dig "username" .Init.randomUsername .State | quote }}
    password: {{ dig "password" .Init.randomPassword .State | quote }}
  outputs: |
    host: {{ .State.service }}
    port: 5432
    name: {{ .State.database }}
    database: {{ .State.database }}
    username: {{ .State.username }}
    password: {{ encodeSecretRef .State.service "password" }}
  manifests: |
    - apiVersion: v1
      kind: Secret
      metadata:
        name: {{ .State.service }}
        annotations:
          k8s.score.dev/source-workload: {{ .SourceWorkload }}
          k8s.score.dev/resource-uid: {{ .Uid }}
          k8s.score.dev/resource-guid: {{ .Guid }}
      data:
        password: {{ .State.password | b64enc }}
    - apiVersion: apps/v1
      kind: StatefulSet
      metadata:
        name: {{ .State.service }}
        annotations:
          k8s.score.dev/source-workload: {{ .SourceWorkload }}
          k8s.score.dev/resource-uid: {{ .Uid }}
          k8s.score.dev/resource-guid: {{ .Guid }}
      spec:
        replicas: 1
        serviceName: {{ .State.service }}
        selector:
          matchLabels:
            scoreWorkload: {{ .SourceWorkload }}
            app: {{ .State.service }}
        template:
          metadata:
            labels:
              scoreWorkload: {{ .SourceWorkload }}
              app: {{ .State.service }}
            annotations:
              k8s.score.dev/source-workload: {{ .SourceWorkload }}
              k8s.score.dev/resource-uid: {{ .Uid }}
              k8s.score.dev/resource-guid: {{ .Guid }}
          spec:
            containers:
            - name: postgres-db
              image: postgres:16
              ports:
              - name: postgres
                containerPort: 5432
              env:
              - name: POSTGRES_USER
                value: {{ .State.username | quote }}
              - name: POSTGRES_PASSWORD
                valueFrom:
                  secretKeyRef:
                    name: {{ .State.service }}
                    key: password
              - name: POSTGRES_DB
                value: {{ .State.database | quote }}
              volumeMounts:
              - name: pv-data
                mountPath: /var/lib/postgresql/data
              readinessProbe:
                exec:
                  command: 
                  - pg_isready
                  - -U
                  - {{ .State.username | quote }}
                  - -d
                  - {{ .State.database | quote }}
                periodSeconds: 3
        volumeClaimTemplates:
        - metadata:
            name: pv-data
            annotations:
              k8s.score.dev/source-workload: {{ .SourceWorkload }}
              k8s.score.dev/resource-uid: {{ .Uid }}
              k8s.score.dev/resource-guid: {{ .Guid }}
          spec:
            accessModes: ["ReadWriteOnce"]
            resources:
              requests:
                storage: 1Gi
    - apiVersion: v1
      kind: Service
      metadata:
        name: {{ .State.service }}
        annotations:
          k8s.score.dev/source-workload: {{ .SourceWorkload }}
          k8s.score.dev/resource-uid: {{ .Uid }}
          k8s.score.dev/resource-guid: {{ .Guid }}
      spec:
        selector:
          scoreWorkload: {{ .SourceWorkload }}
          app: {{ .State.service }}
        type: ClusterIP
        ports:
        - port: 5432
          targetPort: 5432

- uri: template://default-provisioners/redis
  type: redis
  init: |
    randomServiceName: redis-{{ randAlphaNum 6 | lower }}
    randomPassword: {{ randAlphaNum 16 | quote }}
  state: |
    service: {{ dig "service" .Init.randomServiceName .State | quote }}
    username: default
    password: {{ dig "password" .Init.randomPassword .State | quote }}
  outputs: |
    host: {{ .State.service }}
    port: 6379
    username: {{ .State.username }}
    password: {{ encodeSecretRef .State.service "password" }}
  manifests: |
    - apiVersion: v1
      kind: Secret
      metadata:
        name: {{ .State.service }}
        annotations:
          k8s.score.dev/source-workload: {{ .SourceWorkload }}
          k8s.score.dev/resource-uid: {{ .Uid }}
          k8s.score.dev/resource-guid: {{ .Guid }}
      data:
        password: {{ .State.password | b64enc }}
        redis.conf: {{ printf "requirepass %s\nport 6379\nsave 60 1\nloglevel warning\n" .State.password | b64enc }}
    - apiVersion: apps/v1
      kind: StatefulSet
      metadata:
        name: {{ .State.service }}
        annotations:
          k8s.score.dev/source-workload: {{ .SourceWorkload }}
          k8s.score.dev/resource-uid: {{ .Uid }}
          k8s.score.dev/resource-guid: {{ .Guid }}
      spec:
        replicas: 1
        serviceName: {{ .State.service }}
        selector:
          matchLabels:
            scoreWorkload: {{ .SourceWorkload }}
            app: {{ .State.service }}
        template:
          metadata:
            labels:
              scoreWorkload: {{ .SourceWorkload }}
              app: {{ .State.service }}
            annotations:
              k8s.score.dev/source-workload: {{ .SourceWorkload }}
              k8s.score.dev/resource-uid: {{ .Uid }}
              k8s.score.dev/resource-guid: {{ .Guid }}
          spec:
            containers:
            - name: redis
              image: redis:7
              ports:
              - name: redis
                containerPort: 6379
              volumeMounts:
              - name: redis-data
                mountPath: /data
              - name: config
                mountPath: /usr/local/etc/redis
              readinessProbe:
                exec:
                  command: 
                  - redis-cli
                  - ping
                periodSeconds: 3
            volumes:
            - name: config
              secret:
                secretName: {{ .State.service }}
                items:
                - key: redis.conf
                  path: redis.conf
        volumeClaimTemplates:
        - metadata:
            name: redis-data
            annotations:
              k8s.score.dev/source-workload: {{ .SourceWorkload }}
              k8s.score.dev/resource-uid: {{ .Uid }}
              k8s.score.dev/resource-guid: {{ .Guid }}
          spec:
            accessModes: ["ReadWriteOnce"]
            resources:
              requests:
                storage: 1Gi
    - apiVersion: v1
      kind: Service
      metadata:
        name: {{ .State.service }}
        annotations:
          k8s.score.dev/source-workload: {{ .SourceWorkload }}
          k8s.score.dev/resource-uid: {{ .Uid }}
          k8s.score.dev/resource-guid: {{ .Guid }}
      spec:
        selector:
          scoreWorkload: {{ .SourceWorkload }}
          app: {{ .State.service }}
        type: ClusterIP
        ports:
        - port: 6379
          targetPort: 6379
